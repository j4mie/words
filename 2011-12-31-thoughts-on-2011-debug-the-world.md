# Thoughts on 2012: Debug The World

[Jamie Matthews](http://twitter.com/j4mie), December 31 2011.

*tl;dr: programmers embody a unique combination of attributes: power over the raw material the modern world is made from (software), and a rational, liberal, moral approach to life. We should work to understand this power and use it to improve things.*

As 2011 ends, the world feels poised on the edge of change, for better or worse. Economies and currencies are failing, societies are stratifying, populations and their leaders across the world are becoming increasingly hostile towards one another, capitalism is backed into a corner. The climate may have reached a tipping point, transport networks are grinding to a halt, culture is fragmenting.

Given the weight of anticipation and doubt about the future resting on our shoulders, few in the programming community seem to have noticed that we hold the keys to the kingdom. In the new industrial revolution, we dig the mines, we operate the looms, we build the steam engines. To quote [Eben Moglen](http://www.softwarefreedom.org/events/2011/fosdem/moglen-fosdem-keynote.html):

> Software is what the 21st century is made of. What steel was to the economy of the 20th century, what steel was to the power of the 20th century, what steel was to the politics of the 20th century, software is now. It is the crucial building block, the component out of which everything else is made.

The power wielded by those who create software goes further than Moglen's steel analogy. Once steel has been created, it bends to the will of anyone who wants to work with it. Steel is a dumb, passive product: once a bridge is built there is no going back, and your enemies are free to march their armies across it. In contrast, software is dynamic and active throughout its life. The towering edifices of complexity we call software systems can be changed indefinitely. Their behaviour and biases can be modified, and only those who understand them have the power to assert control over them.

Moglen argues that centralisation and commercialisation of communications infrastructure in general, and social networks in particular, must be avoided at all costs to ensure our continued safety and freedom. He might be right, but I think the point goes deeper than arguments about free software and free societies.

As programmers, we are in a unique position. We control the raw materials that the political, financial, legal and industrial systems that run the entire planet are built from. And, crucially, most of the programmers I know are intelligent, balanced, moral, rigorous, rational and motivated by a genuine desire to improve the world. Programmers are able to clearly understand and reason about reality, because that's just part of the job description. And reality, as the saying goes, has a distinct liberal bias.

This combination of power and rationality is what makes the position of the programmer in 2012 so important. Of course, there are exceptions, probably many of them, on all sides. But given the choice of socialising with politicians, bankers, lawyers or programmers, I know who I'd pick.

Commentary on the global situation we face as the sun rises on New Year's Day often ends with cautious, non-specific optimism. Austerity, change and collapse are painful and challenging, but they present great opportunities. 2012 is a “daunting prospect,” says [Jon Snow](http://blogs.channel4.com/snowblog/2012-hold-world/16868), but it may “provoke some return to ‘small is beautiful’ thoughts – the renewal of community and neighbourhood”.

In that spirit, I am not proposing that an army of politicised, militarised programmers rises up to overthrow corrupt regimes (armed only with keyboards, text editors and plenty of coffee). Far from it. My only hope is that we gain a better understanding of the unique position of influence we occupy. It's a painful cliché, but it still applies: with great power comes great responsibility.

Programmers are accustomed to collaborating by working at different levels of abstraction. Some have the skills and motivation to tackle global, distributed problems like decentralised networks, mesh infrastructure, anonymity and encryption. The very best of luck to them. The rest of us can create software to benefit a community as small as a single town, street or apartment block. A simple Django, Rails or PHP application could allow your neighbours to exchange books, share power tools, or organise car pools. Why not learn to wire up your house with a few Arduinos to monitor and reduce your energy consumption? Take some local government data, analyse and visualise it, and publish your findings online?

Just as vital as practical problem solving is education. I realise that my characterisation of schooled, middle-class geeks as sole bearers of the future of mankind may, on the surface, sound pompous and elitist. In fact, the opposite is true. Unlike political or financial influence, the ability to create software is accessible to anyone, not just those with the right contacts and rich parents. Teach kids to code. Help people understand technology better. Get involved with something educational and empowering like [Young Rewired State](http://youngrewiredstate.org/). 2012 will be the year of [Raspberry Pi](http://www.raspberrypi.org/). Buy one, figure out what you can do with it. Share it with others.

But these are just ideas, suggestions. Programmers have wildly differing areas of expertise and interest, and so sweeping prescriptions and direct calls to action have no place here. Instead, debug the world around you. Look for something that is broken, however small and local and insignificant, and try to make it a little bit less broken. If you know someone else whose skills are better suited to fixing the problem, assign the bug to them and see if they can help.

Debug the world, hack the planet, [program or be programmed](http://www.orbooks.com/catalog/program/). I'll finish with an old favourite: The Zen of Python. Read this with code in mind (and ignore the in-jokes), and you'll find a good set of suggestions for arriving at the correct mindset for writing software. But then try reading it with politics and society and culture in mind. I was surprised at how much still applies. Happy New Year.

    Beautiful is better than ugly.
    Explicit is better than implicit.
    Simple is better than complex.
    Complex is better than complicated.
    Flat is better than nested.
    Sparse is better than dense.
    Readability counts.
    Special cases aren't special enough to break the rules.
    Although practicality beats purity.
    Errors should never pass silently.
    Unless explicitly silenced.
    In the face of ambiguity, refuse the temptation to guess.
    There should be one-- and preferably only one --obvious way to do it.
    Although that way may not be obvious at first unless you're Dutch.
    Now is better than never.
    Although never is often better than *right* now.
    If the implementation is hard to explain, it's a bad idea.
    If the implementation is easy to explain, it may be a good idea.
    Namespaces are one honking great idea -- let's do more of those!
